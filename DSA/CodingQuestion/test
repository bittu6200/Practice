5:35
-------------------
bs
n=arr.length-1
f=0
l=n-1
while(f<=l){
mid = (f+l)/2
if(arr(mid)==key
    return mid
else if (key>arr(mid))
    f=mid+1
else if(key<arr(mid)
    l= mid -1
   }
............................................

stack :
({{}})

def isbalancedparanthesis(str:String){

val stack=new Stack[Char]()
for(char<-str){
 if(char=="(" || char=="{" ||char=="[" ){
        stack.puch(char) }
 else if(char==")" || char=="}" ||char=="]" )
 {
 if(stack.empty){
    return false
   }
 val top=stack.pop()
 else if(char=="(" && top!=')' || char=="{"&& top!='}' ||char=="["&& top!=']' )
        return false
   }
   }
   }
   stack.isEmpty()
   }
   }
---------------------------------------------------
def isPalindrom(str :String):Boolean={
     str==srt.reverse
  }
  def subStringPalindrome(substr:String):String={
  if(ispalindrome(substr))
  {
  "all ready palindrome"
  }
  for(i<-0 to substr.length){
  str1=substr.patch(i,"",1)
  if(isPalindrome(str1)){
  str1
  }
  }
   for(i<-0 to substr.lenth){
    str1=substr.patch(i,"",2)
    if(isPalindrome(str1)){
    str1
    }
    }
    }
}
..........................................
var arr=List(4,5,6,72,9)
def kthMinimum(list: List[Int],var k:Int ){
 list1=list.sorted
 list1(k-1)
 }

 def(arr,2)

................................................
tree
: node, left, right

class Node(value:Int,left:Node=null,right:Node=null)

class tree{
var root : node =null

def insertValue(value:Int){
if(root==null)
{
new node(value)
}
else{
if(value>root.value){
root.right=new node(value)
}
else{
root.left=new Node(value)
}
}

...................................

graph

class Graph{
val adjanceyList: mutable.map(Int,List[Int])=mutable.map()

def InsertValue(vertex1:Int,vertex2:Int){

adjanceyList.map(vertex1)+=vertex2
adjanceyList.map(vertex2)+=vertex1

}

def NoofNode():Iterable[Int]=adjancey.keys
//////////////////////////////////////////////////////////

insertion sort : compare that value to it precedence
selection sort : find min and max index swap with unsored part with first element
bubble sort: compare to adjancey element and nswap then if it is lager value ............
quik sort : divide and conqure
///////////////////////////////////////////////////////

var arr=Array(3,1,3,8,9,12,90)

def selectionSort(arr:Array[Int]){

for(i<-0 Untit n-1){
var minimumOndex=i
for(j<-i+1 until n){
if(arr(minimumIndex)>arr(j)){
minimumIndex=j
}
}
if(i!=minimumIndex){
temp=arr(minimumIndex)
arr(minimumIndex)=arr(i)
temp=arr(minimumIndex)
}
}
}
----------------------------------------

thank you 6:30
















